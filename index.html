<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Cosmic Map Engine ‚Äì All Interactions</title>
<style>
  * {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
  }

  html, body {
    height: 100%;
    background: radial-gradient(circle at top, #1b1533 0, #05030a 55%, #000000 100%);
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    color: #f5f0ff;
    overflow: hidden;
  }

  #app {
    display: flex;
    flex-direction: column;
    height: 100%;
  }

  #toolbar {
    flex: 0 0 auto;
    padding: 8px 12px;
    display: flex;
    align-items: center;
    gap: 10px;
    background: linear-gradient(to right, #0b061a, #120a2f);
    box-shadow: 0 4px 18px rgba(0,0,0,0.6);
    border-bottom: 1px solid rgba(255,255,255,0.05);
    z-index: 1000;
  }

  #toolbar span.label {
    font-size: 12px;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    color: #aaa0ff;
  }

  .btn {
    border-radius: 999px;
    border: 1px solid rgba(255,255,255,0.16);
    padding: 5px 12px;
    font-size: 12px;
    background: rgba(255,255,255,0.02);
    color: #f5f0ff;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    gap: 4px;
    backdrop-filter: blur(6px);
    transition: background 0.15s, transform 0.15s, box-shadow 0.15s, border-color 0.15s;
  }
  .btn:hover {
    background: rgba(135,106,255,0.2);
    transform: translateY(-1px);
    box-shadow: 0 0 12px rgba(120,90,255,0.45);
    border-color: rgba(187,167,255,0.8);
  }
  .btn:active {
    transform: translateY(0);
    box-shadow: none;
  }

  #hint {
    font-size: 11px;
    color: #c8c3ff;
    opacity: 0.85;
  }

  #map-container {
    position: relative;
    flex: 1 1 auto;
    overflow: hidden;
    background: radial-gradient(circle at 10% -20%, rgba(150,120,255,0.6) 0, transparent 45%),
                radial-gradient(circle at 90% 120%, rgba(120,210,255,0.35) 0, transparent 55%),
                #05030a;
  }

  #map {
    position: absolute;
    inset: 0;
    cursor: grab;
    user-select: none;
    overflow: hidden;
  }
  #map.dragging {
    cursor: grabbing;
  }

  .tile-layer {
    position: absolute;
    inset: 0;
  }

  .tile {
    position: absolute;
    width: 256px;
    height: 256px;
    image-rendering: pixelated;
  }

  .overlay-layer {
    position: absolute;
    inset: 0;
    pointer-events: none;
  }

  #overlay-canvas {
    width: 100%;
    height: 100%;
  }

  .marker-layer {
    position: absolute;
    inset: 0;
    pointer-events: none;
  }

  .marker {
    position: absolute;
    width: 18px;
    height: 18px;
    border-radius: 999px;
    background: radial-gradient(circle at 30% 20%, #ffffff 0, #f1e6ff 25%, #a781ff 60%, #2b1f6f 100%);
    box-shadow: 0 0 12px rgba(165,129,255,0.9);
    transform: translate(-50%, -50%);
    pointer-events: auto;
    cursor: pointer;
  }

  .marker.user {
    width: 16px;
    height: 16px;
    background: radial-gradient(circle, #ffffff 0, #8bf4ff 35%, #2a9dff 70%, #0048ff 100%);
    box-shadow: 0 0 16px rgba(0,181,255,0.9);
    animation: userPulse 1.7s infinite;
  }

  @keyframes userPulse {
    0%   { box-shadow: 0 0 4px rgba(0,181,255,0.9); transform: translate(-50%, -50%) scale(1);   }
    70%  { box-shadow: 0 0 18px rgba(0,181,255,0);   transform: translate(-50%, -50%) scale(1.6); }
    100% { box-shadow: 0 0 4px rgba(0,181,255,0.0); transform: translate(-50%, -50%) scale(1);   }
  }

  .marker.selected {
    outline: 2px solid rgba(255,255,255,0.9);
    outline-offset: 2px;
  }

  .popup {
    position: absolute;
    min-width: 140px;
    max-width: 220px;
    padding: 8px 10px;
    background: rgba(12,7,35,0.96);
    color: #f5f0ff;
    border-radius: 10px;
    border: 1px solid rgba(210,190,255,0.35);
    box-shadow: 0 10px 22px rgba(0,0,0,0.8);
    font-size: 12px;
    transform: translate(-50%, calc(-100% - 10px));
    pointer-events: auto;
    z-index: 20;
  }
  .popup::after {
    content: "";
    position: absolute;
    left: 50%;
    bottom: -7px;
    transform: translateX(-50%);
    border-width: 7px 7px 0 7px;
    border-style: solid;
    border-color: rgba(12,7,35,0.96) transparent transparent transparent;
  }

  .popup-title {
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 0.09em;
    color: #9a8bff;
    margin-bottom: 2px;
  }
  .popup-body {
    font-size: 12px;
    color: #f3edff;
    margin-bottom: 6px;
  }
  .popup-meta {
    font-size: 11px;
    color: #b4b0ff;
  }

  .selection-rect {
    position: absolute;
    border: 1px dashed rgba(201,201,255,0.8);
    background: rgba(124,123,255,0.12);
    pointer-events: none;
    z-index: 15;
  }

  #zoom-controls {
    position: absolute;
    right: 10px;
    top: 12px;
    display: flex;
    flex-direction: column;
    gap: 6px;
    z-index: 30;
  }
  .zoom-btn {
    width: 30px;
    height: 30px;
    border-radius: 999px;
    border: 1px solid rgba(255,255,255,0.2);
    background: rgba(6,4,25,0.95);
    color: #f5f0ff;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    backdrop-filter: blur(10px);
    transition: background 0.12s, transform 0.12s, box-shadow 0.12s;
  }
  .zoom-btn:hover {
    background: rgba(112,84,255,0.95);
    box-shadow: 0 0 12px rgba(120,90,255,0.7);
    transform: translateY(-1px);
  }

  #status {
    position: absolute;
    left: 10px;
    bottom: 10px;
    padding: 6px 8px;
    border-radius: 999px;
    font-size: 11px;
    background: rgba(6,4,25,0.92);
    border: 1px solid rgba(200,190,255,0.22);
    color: #dcd8ff;
    pointer-events: none;
    backdrop-filter: blur(8px);
  }
  #status strong {
    color: #9a8bff;
  }
</style>
</head>
<body>
<div id="app">
  <div id="toolbar">
    <span class="label">Cosmic Map Engine</span>
    <button id="locate-btn" class="btn">üìç My location</button>
    <button id="route-btn" class="btn">üßµ Route last 2 markers</button>
    <button id="clear-btn" class="btn">üßπ Clear markers</button>
    <div style="flex:1"></div>
    <div id="hint">
      Click: add marker ¬∑ Click marker: popup ¬∑ Shift+drag: radius ¬∑ Alt+drag: box select ¬∑ Scroll / +/-: zoom
    </div>
  </div>
  <div id="map-container">
    <div id="map">
      <div class="tile-layer" id="tile-layer"></div>
      <canvas id="overlay-canvas" class="overlay-layer"></canvas>
      <div class="marker-layer" id="marker-layer"></div>
      <div id="zoom-controls">
        <div id="zoom-in" class="zoom-btn">+</div>
        <div id="zoom-out" class="zoom-btn">‚àí</div>
      </div>
      <div id="status">Ready.</div>
    </div>
  </div>
</div>

<script>
  // =========================
  // Core map state
  // =========================
  const mapEl = document.getElementById('map');
  const tileLayer = document.getElementById('tile-layer');
  const markerLayer = document.getElementById('marker-layer');
  const overlayCanvas = document.getElementById('overlay-canvas');
  const overlayCtx = overlayCanvas.getContext('2d');
  const statusEl = document.getElementById('status');

  let mapWidth = mapEl.clientWidth;
  let mapHeight = mapEl.clientHeight;

  let zoom = 3;
  let center = { lat: 0, lng: 0 }; // world center

  let isDragging = false;
  let lastMouse = { x: 0, y: 0 };

  // markers & popups
  const markers = [];
  let popupEl = null;
  let selectedMarkers = [];

  // radius selection
  let radiusSelecting = false;
  let radiusStart = null;
  let radiusEnd = null;

  // box selection
  let boxSelecting = false;
  let boxRectEl = null;
  let boxStart = null;

  // viewport resize
  function resize() {
    mapWidth = mapEl.clientWidth;
    mapHeight = mapEl.clientHeight;
    overlayCanvas.width = mapWidth;
    overlayCanvas.height = mapHeight;
    render();
  }
  window.addEventListener('resize', resize);
  resize();

  // =========================
  // Web Mercator helpers
  // =========================
  const TILE_SIZE = 256;

  function lngToX(lng, z) {
    return (lng + 180) / 360 * (TILE_SIZE * Math.pow(2, z));
  }

  function latToY(lat, z) {
    const rad = lat * Math.PI / 180;
    const n = Math.log(Math.tan(Math.PI / 4 + rad / 2));
    return (1 - n / Math.PI) / 2 * (TILE_SIZE * Math.pow(2, z));
  }

  function xToLng(x, z) {
    return x / (TILE_SIZE * Math.pow(2, z)) * 360 - 180;
  }

  function yToLat(y, z) {
    const n = Math.PI - 2 * Math.PI * y / (TILE_SIZE * Math.pow(2, z));
    return 180 / Math.PI * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));
  }

  function latLngToGlobalPixel(lat, lng, z) {
    return {
      x: lngToX(lng, z),
      y: latToY(lat, z)
    };
  }

  function globalPixelToLatLng(x, y, z) {
    return {
      lat: yToLat(y, z),
      lng: xToLng(x, z)
    };
  }

  function latLngToScreen(lat, lng) {
    const centerPx = latLngToGlobalPixel(center.lat, center.lng, zoom);
    const pointPx = latLngToGlobalPixel(lat, lng, zoom);
    const dx = pointPx.x - centerPx.x;
    const dy = pointPx.y - centerPx.y;
    return {
      x: mapWidth / 2 + dx,
      y: mapHeight / 2 + dy
    };
  }

  function screenToLatLng(x, y) {
    const centerPx = latLngToGlobalPixel(center.lat, center.lng, zoom);
    const worldX = centerPx.x + (x - mapWidth / 2);
    const worldY = centerPx.y + (y - mapHeight / 2);
    return globalPixelToLatLng(worldX, worldY, zoom);
  }

  // =========================
  // Tile rendering
  // =========================
  function renderTiles() {
    tileLayer.innerHTML = '';
    const centerPx = latLngToGlobalPixel(center.lat, center.lng, zoom);

    const startX = centerPx.x - mapWidth / 2;
    const startY = centerPx.y - mapHeight / 2;

    const startTileX = Math.floor(startX / TILE_SIZE);
    const startTileY = Math.floor(startY / TILE_SIZE);

    const endTileX = Math.floor((startX + mapWidth) / TILE_SIZE);
    const endTileY = Math.floor((startY + mapHeight) / TILE_SIZE);

    for (let tx = startTileX - 1; tx <= endTileX + 1; tx++) {
      for (let ty = startTileY - 1; ty <= endTileY + 1; ty++) {
        const tileX = ((tx % Math.pow(2, zoom)) + Math.pow(2, zoom)) % Math.pow(2, zoom);
        const tileY = ty;

        if (tileY < 0 || tileY >= Math.pow(2, zoom)) continue;

        const img = document.createElement('img');
        img.className = 'tile';
        img.draggable = false;
        img.src = `https://tile.openstreetmap.org/${zoom}/${tileX}/${tileY}.png`;

        const px = tx * TILE_SIZE - startX;
        const py = ty * TILE_SIZE - startY;

        img.style.transform = `translate(${px}px, ${py}px)`;
        tileLayer.appendChild(img);
      }
    }
  }

  // =========================
  // Marker engine
  // =========================
  function addMarker(lat, lng, opts = {}) {
    const el = document.createElement('div');
    el.className = 'marker';
    if (opts.type === 'user') el.classList.add('user');

    const marker = { id: Date.now() + Math.random(), lat, lng, el, opts };
    markers.push(marker);
    markerLayer.appendChild(el);

    el.addEventListener('click', (e) => {
      e.stopPropagation();
      handleMarkerClick(marker);
    });

    renderMarker(marker);
    return marker;
  }

  function renderMarker(marker) {
    const pt = latLngToScreen(marker.lat, marker.lng);
    marker.el.style.left = pt.x + 'px';
    marker.el.style.top = pt.y + 'px';
  }

  function renderMarkers() {
    markers.forEach(renderMarker);
  }

  function clearMarkers() {
    markers.forEach(m => m.el.remove());
    markers.length = 0;
    hidePopup();
    selectedMarkers = [];
    updateStatus('Markers cleared.');
  }

  function handleMarkerClick(marker) {
    selectedMarkers = [marker];
    document.querySelectorAll('.marker.selected').forEach(el => el.classList.remove('selected'));
    marker.el.classList.add('selected');
    const pt = latLngToScreen(marker.lat, marker.lng);
    const distStr = distanceFromCenterKm(marker).toFixed(2);
    showPopup(pt.x, pt.y, {
      title: marker.opts.type === 'user' ? 'You are here' : 'Marker',
      body: `Lat ${marker.lat.toFixed(4)}, Lng ${marker.lng.toFixed(4)}`,
      meta: `Distance from center: ${distStr} km`
    });
  }

  function distanceFromCenterKm(marker) {
    const R = 6371;
    const dLat = (marker.lat - center.lat) * Math.PI/180;
    const dLng = (marker.lng - center.lng) * Math.PI/180;
    const a = Math.sin(dLat/2)**2 +
              Math.cos(center.lat * Math.PI/180) *
              Math.cos(marker.lat * Math.PI/180) *
              Math.sin(dLng/2)**2;
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R * c;
  }

  // =========================
  // Popup engine
  // =========================
  function showPopup(x, y, { title, body, meta }) {
    hidePopup();
    popupEl = document.createElement('div');
    popupEl.className = 'popup';
    popupEl.innerHTML = `
      <div class="popup-title">${title}</div>
      <div class="popup-body">${body}</div>
      <div class="popup-meta">${meta}</div>
    `;
    mapEl.appendChild(popupEl);
    popupEl.style.left = x + 'px';
    popupEl.style.top = y + 'px';
  }

  function hidePopup() {
    if (popupEl) {
      popupEl.remove();
      popupEl = null;
    }
  }

  // =========================
  // Overlay drawing (radius, routes)
  // =========================
  let routeLine = null; // { from: {lat,lng}, to: {lat,lng} }

  function renderOverlay() {
    overlayCtx.clearRect(0, 0, mapWidth, mapHeight);

    // radius selection
    if (radiusSelecting && radiusStart && radiusEnd) {
      overlayCtx.save();
      overlayCtx.strokeStyle = 'rgba(173,148,255,0.9)';
      overlayCtx.fillStyle = 'rgba(140,110,255,0.12)';
      overlayCtx.lineWidth = 2;
      const dx = radiusEnd.x - radiusStart.x;
      const dy = radiusEnd.y - radiusStart.y;
      const r = Math.sqrt(dx*dx + dy*dy);
      overlayCtx.beginPath();
      overlayCtx.arc(radiusStart.x, radiusStart.y, r, 0, Math.PI * 2);
      overlayCtx.fill();
      overlayCtx.stroke();
      overlayCtx.restore();
    }

    // route line
    if (routeLine) {
      const fromPt = latLngToScreen(routeLine.from.lat, routeLine.from.lng);
      const toPt = latLngToScreen(routeLine.to.lat, routeLine.to.lng);
      overlayCtx.save();
      overlayCtx.strokeStyle = 'rgba(0,230,255,0.9)';
      overlayCtx.lineWidth = 3;
      overlayCtx.setLineDash([8, 6]);
      overlayCtx.beginPath();
      overlayCtx.moveTo(fromPt.x, fromPt.y);
      overlayCtx.lineTo(toPt.x, toPt.y);
      overlayCtx.stroke();
      overlayCtx.restore();
    }
  }

  function setRouteBetweenLastTwoMarkers() {
    if (markers.length < 2) {
      updateStatus('Need at least 2 markers to draw a route.');
      return;
    }
    const a = markers[markers.length - 2];
    const b = markers[markers.length - 1];
    routeLine = { from: { lat: a.lat, lng: a.lng }, to: { lat: b.lat, lng: b.lng } };
    const dist = distanceKm(a.lat, a.lng, b.lat, b.lng).toFixed(2);
    updateStatus(`Route drawn between last 2 markers ¬∑ ${dist} km`);
    renderOverlay();
  }

  function distanceKm(lat1, lng1, lat2, lng2) {
    const R = 6371;
    const dLat = (lat2 - lat1) * Math.PI/180;
    const dLng = (lng2 - lng1) * Math.PI/180;
    const a = Math.sin(dLat/2)**2 +
              Math.cos(lat1 * Math.PI/180) *
              Math.cos(lat2 * Math.PI/180) *
              Math.sin(dLng/2)**2;
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R * c;
  }

  // =========================
  // Radius selection + filtering
  // =========================
  function beginRadiusSelection(startX, startY) {
    radiusSelecting = true;
    radiusStart = { x: startX, y: startY };
    radiusEnd = { x: startX, y: startY };
  }

  function updateRadiusSelection(x, y) {
    if (!radiusSelecting) return;
    radiusEnd = { x, y };
    renderOverlay();
  }

  function endRadiusSelection() {
    if (!radiusSelecting || !radiusStart || !radiusEnd) {
      radiusSelecting = false;
      radiusStart = radiusEnd = null;
      renderOverlay();
      return;
    }
    const dx = radiusEnd.x - radiusStart.x;
    const dy = radiusEnd.y - radiusStart.y;
    const r = Math.sqrt(dx*dx + dy*dy);
    const centerLatLng = screenToLatLng(radiusStart.x, radiusStart.y);

    const pt2 = screenToLatLng(radiusStart.x + r, radiusStart.y);
    const radiusKm = distanceKm(centerLatLng.lat, centerLatLng.lng, pt2.lat, pt2.lng);

    const inside = [];
    markers.forEach(m => {
      const d = distanceKm(centerLatLng.lat, centerLatLng.lng, m.lat, m.lng);
      if (d <= radiusKm) inside.push(m);
    });

    selectedMarkers = inside;
    document.querySelectorAll('.marker.selected').forEach(el => el.classList.remove('selected'));
    inside.forEach(m => m.el.classList.add('selected'));

    updateStatus(`Radius: ${radiusKm.toFixed(2)} km ¬∑ Selected markers: ${inside.length}`);
    radiusSelecting = false;
    radiusStart = radiusEnd = null;
    renderOverlay();
  }

  // =========================
  // Box selection
  // =========================
  function beginBoxSelection(startX, startY) {
    boxSelecting = true;
    boxStart = { x: startX, y: startY };
    if (!boxRectEl) {
      boxRectEl = document.createElement('div');
      boxRectEl.className = 'selection-rect';
      mapEl.appendChild(boxRectEl);
    }
    updateBoxSelection(startX, startY);
  }

  function updateBoxSelection(x, y) {
    if (!boxSelecting || !boxStart) return;
    const minX = Math.min(boxStart.x, x);
    const maxX = Math.max(boxStart.x, x);
    const minY = Math.min(boxStart.y, y);
    const maxY = Math.max(boxStart.y, y);
    boxRectEl.style.left = minX + 'px';
    boxRectEl.style.top = minY + 'px';
    boxRectEl.style.width = (maxX - minX) + 'px';
    boxRectEl.style.height = (maxY - minY) + 'px';
  }

  function endBoxSelection(endX, endY) {
    if (!boxSelecting || !boxStart) {
      boxSelecting = false;
      if (boxRectEl) boxRectEl.style.display = 'none';
      return;
    }
    const minX = Math.min(boxStart.x, endX);
    const maxX = Math.max(boxStart.x, endX);
    const minY = Math.min(boxStart.y, endY);
    const maxY = Math.max(boxStart.y, endY);

    selectedMarkers = [];
    document.querySelectorAll('.marker.selected').forEach(el => el.classList.remove('selected'));

    markers.forEach(m => {
      const pt = latLngToScreen(m.lat, m.lng);
      if (pt.x >= minX && pt.x <= maxX && pt.y >= minY && pt.y <= maxY) {
        selectedMarkers.push(m);
        m.el.classList.add('selected');
      }
    });

    updateStatus(`Box selected markers: ${selectedMarkers.length}`);
    boxSelecting = false;
    if (boxRectEl) {
      boxRectEl.style.display = 'none';
    }
  }

  // =========================
  // Map interactions
  // =========================
  mapEl.addEventListener('mousedown', (e) => {
    const rect = mapEl.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    lastMouse = { x: e.clientX, y: e.clientY };

    if (e.shiftKey) {
      beginRadiusSelection(x, y);
      return;
    }
    if (e.altKey) {
      beginBoxSelection(x, y);
      return;
    }

    isDragging = true;
    mapEl.classList.add('dragging');
  });

  window.addEventListener('mousemove', (e) => {
    const rect = mapEl.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    if (radiusSelecting) {
      updateRadiusSelection(x, y);
      return;
    }
    if (boxSelecting) {
      updateBoxSelection(x, y);
      return;
    }

    if (!isDragging) return;
    const dx = e.clientX - lastMouse.x;
    const dy = e.clientY - lastMouse.y;
    lastMouse = { x: e.clientX, y: e.clientY };

    const centerPx = latLngToGlobalPixel(center.lat, center.lng, zoom);
    const newCenterPx = {
      x: centerPx.x - dx,
      y: centerPx.y - dy
    };
    const newCenterLatLng = globalPixelToLatLng(newCenterPx.x, newCenterPx.y, zoom);
    center = newCenterLatLng;
    render();
  });

  window.addEventListener('mouseup', (e) => {
    const rect = mapEl.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    if (radiusSelecting) {
      endRadiusSelection();
      return;
    }
    if (boxSelecting) {
      endBoxSelection(x, y);
      return;
    }

    if (isDragging) {
      isDragging = false;
      mapEl.classList.remove('dragging');
      return;
    }
  });

  mapEl.addEventListener('click', (e) => {
    if (radiusSelecting || boxSelecting || isDragging) return;

    const rect = mapEl.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const latlng = screenToLatLng(x, y);
    const marker = addMarker(latlng.lat, latlng.lng, { type: 'normal' });
    updateStatus(`Marker added @ ${marker.lat.toFixed(4)}, ${marker.lng.toFixed(4)}`);
  });

  mapEl.addEventListener('dblclick', (e) => {
    e.preventDefault();
    const rect = mapEl.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    zoomAtPoint(1, x, y);
  });

  mapEl.addEventListener('wheel', (e) => {
    e.preventDefault();
    const rect = mapEl.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const delta = e.deltaY > 0 ? -1 : 1;
    zoomAtPoint(delta, x, y);
  }, { passive: false });

  function zoomAtPoint(delta, screenX, screenY) {
    const oldZoom = zoom;
    const newZoom = Math.min(18, Math.max(2, zoom + delta));
    if (newZoom === zoom) return;
    const before = screenToLatLng(screenX, screenY);
    zoom = newZoom;
    const after = screenToLatLng(screenX, screenY);

    center.lat += before.lat - after.lat;
    center.lng += before.lng - after.lng;

    updateStatus(`Zoom: ${zoom}`);
    render();
  }

  // zoom buttons
  document.getElementById('zoom-in').addEventListener('click', () => {
    zoomAtPoint(1, mapWidth/2, mapHeight/2);
  });
  document.getElementById('zoom-out').addEventListener('click', () => {
    zoomAtPoint(-1, mapWidth/2, mapHeight/2);
  });

  // =========================
  // Geolocation
  // =========================
  document.getElementById('locate-btn').addEventListener('click', () => {
    if (!navigator.geolocation) {
      updateStatus('Geolocation not supported by this browser.');
      return;
    }
    updateStatus('Locating...');
    navigator.geolocation.getCurrentPosition((pos) => {
      const { latitude, longitude } = pos.coords;
      center = { lat: latitude, lng: longitude };
      addMarker(latitude, longitude, { type: 'user' });
      zoom = Math.max(12, zoom);
      updateStatus(`Centered on your location.`);
      render();
    }, (err) => {
      updateStatus('Failed to get location.');
    });
  });

  // =========================
  // Route + clear controls
  // =========================
  document.getElementById('route-btn').addEventListener('click', () => {
    setRouteBetweenLastTwoMarkers();
  });
  document.getElementById('clear-btn').addEventListener('click', () => {
    routeLine = null;
    clearMarkers();
    renderOverlay();
  });

  // =========================
  // Status helper
  // =========================
  function updateStatus(msg) {
    statusEl.innerHTML = `<strong>Status:</strong> ${msg}`;
  }

  // =========================
  // Render
  // =========================
  function render() {
    renderTiles();
    renderMarkers();
    renderOverlay();
  }

  // initial render
  render();
  updateStatus('Ready. Click map to add markers.');
</script>
</body>
</html>
